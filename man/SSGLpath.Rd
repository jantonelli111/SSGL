% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Main.R
\name{SSGLpath}
\alias{SSGLpath}
\title{Estimate grouped spike and slab lasso regression model along a path}
\usage{
SSGLpath(Y, X, lambda1, lambda0, lambda0seq = seq(lambda1, lambda0,
  length = 20), groups, a = 1, b = length(unique(groups)), M = 10,
  error = 0.001, forceGroups = c())
}
\arguments{
\item{Y}{The outcome to be analyzed}

\item{X}{An n by p matrix of covariates}

\item{lambda1}{Prior parameter for the slab component of the prior}

\item{lambda0}{Prior parameter for the spike component of the prior}

\item{lambda0seq}{Sequence of lambda0 grids to iterate through}

\item{groups}{A vector of length p denoting which group each covariate is in}

\item{a}{First hyperparameter for the beta prior denoting the prior probability of being in the slab}

\item{b}{Second hyperparameter for the beta prior denoting the prior probability of being in the slab}

\item{M}{Positive number less than p indicating how often to update theta and sigma. There is no
need to change this unless trying to optimize computation time}

\item{forceGroups}{A vector containing the indices of any groups you wish to automatically
include in the model and not penalize}
}
\value{
A list of values containing the regression coefficients, the intercept, the estimate
        of the residual variance (this is simply the marginal variance of Y if UpdateSigma=FALSE),
        An estimate of theta the prior probability of entering into the slab, and the number of 
        iterations it took to converge
}
\description{
This function takes in an outcome and covariates, and estimates the 
posterior mode of the spike and slab group lasso penalty beginning at
a small value of lambda0 and continuing on a path until the chosen lambda0
}
\examples{

## Here we generate 200 samples from 100 covariates
n = 200
G = 100
x = mvtnorm::rmvnorm(n, sigma=diag(G))


X = matrix(NA, nrow=n, ncol=G*2)

for (g in 1 : G) {
  X[,2*(g-1) + 1] = x[,g]
  X[,2*g] = x[,g]^2
}

Y = 200 + x[,1] + x[,2] + 0.6*x[,2]^2 + rnorm(n, sd=1)

## Now fit model for chosen lambda0 and lambda1 values
modSSGL = SSGLpath(Y=Y, X=X, lambda1=.1, lambda0=10, 
groups = rep(1:G, each=2))

modSSGL
}
